# 运输层定义

运输层协议为运行在不同主机上的应用程序之间提供了逻辑通信（Logic Communication）功能。
创建进程到进程的通信 流量控制机制


## 运输层工作过程

将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段，然后在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络分组并向目的地发送。

路由器仅作用于该数据报的网络层字段；即他们不检查封装在该数据报的运输层报文段的字段。

接收端：网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。然后运输层则处理接收到的报文段，使该报文段中的数据为接受应用进程使用。

![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211213132740.png)

运输层单位为报文段
报文传输  

### 多路复用   多路分解   
报文传输通过源端口号和目的端口号实现
其中UDP协议和TCP协议主要目的是实现在端系统上的两个进程之间的交付服务
UDP只需要再报文段的头部写上源端口和目的端口
TCP需要在报文的头部加上源端口和目的端口，源IP和目的IP，运输层首部字节大小一般为20字节

| TCP          | UDP      |
| ------------ | -------- |
| 可靠数据传输 | 数据交付 |
| 拥塞控制     | 差错检测 |
| 数据交付     |          |
| 差错检测             |          |


## 可靠数据传输

### 1.经过完全可靠信道的可靠数据传输rdt1.0
因为是完全可靠的信道，所以接收方不需要提供任何反馈信息给发送方
### 2.经具有比特差错信道的可靠数据传输rdt2.0
1. [[自动重传请求协议]]
1) 使用了肯定确认（positive acknowledg-ment）和否定确认 (negative acknowledgment)
<img src="https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211220131618.png"/>
差错检测:   以使接收方检测到何时出现了比特差错
因为发送方和接收方通常在不同端系统上执行，发送方需要了解接收方情况的唯一途径是让接收方提供明确的反馈信息给发送方
当发送发收到了接收方发来的信号为NAK的时候，则会重新传送分组文

2) ACK或者NAK分组受损
- 不理解接收方的回答
- 增加足够的检验和比特，不仅可以检测差错还可以恢复差错
- 当发送收到含糊不清的ACK或NAK分组时，只需要重传当前分组即可。冗余引起冗余分组，而这样的困难在于接收方不知道它上次所发送的ACK和NAK是否被发送方正确地收到，解决这一个问题的方式是序号。

###  3.经具有比特差错的丢包信道的可靠数据传输 rdt3.0
在rdt2.x的基础上加入计时器，如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需要传该数据分组即可。
发送方对于定时器的操作：
1. 每发送一个包都需要启动一次定时器 
2. 响应定时器中断 
3. 终止定时器
+ 问题1. 发送方需要等待多久的时间确定丢失的东西呢？  
+ 问题2.解决数据组或者ACk丢失，或者只是分组或者ACK过度延时，采用基于时间的重传机制。

rdt3.0也停等协议，如果我每次发送一个包，都需要等到接收方发送了的信息之后，我才继续发送下一个包，那么性能将会受到影响,对于信道的利用率特别低下。
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221142254.png)
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221142945.png)


通过流水线解决rdt3.0停等协议利用率低下的问题，允许发送发送多个分组而无需等待确认
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221143820.png)


### 实现流水线技术改进的地方：
	1. 增加序号范围
	2. 协议的发送方和接收方两端也许必须缓存多个分组
	3. 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及延时过大的分组

[<img src="https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221150612.png"/>](<![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221150612.png)>)
### 解决流水线的差错恢复有两种基本方法

#### 回退N步GBN/滑动窗口协议

![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211205150025.png)
基序号:定义为最早的未确认分组的序号
下一个序号：最小的未使用序号
窗口长度：最大的允许数N

#####  GBN发送方必须响应三种类型的事件：
+ 上层的调用：上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个以发送但未被确认的分组。
+ 收到一个ACK：GBN协议中，对序号为N的分组确认采取累积确认的方式
+ 超时事件： 回退N步来源于出现丢失和时延过长分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。 **发送方仅使用一个定时器**

在GBN协议中，接收方会丢弃所有失序分组。 
#### 选择重传
通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。
每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组

发送方
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211128155930.png)
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211221154926.png)
接收方
SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到为止，这时才可以将一批分组按序交付给上层
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211128160624.png)
发送方和接受方的窗口并不总是一致 存在两种情况
- 第一种情况
	- ![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211128162132.png)
	- 第二种情况

所有对于发送窗口的大小设置

## 面向连接的TCP
TCP把数据看成一个无结构的，有序的字节流
### TCP报文段
 ![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211129103850.png)

- 源端口号和目的端口号：[[多路复用与多路分解]]
- 序号和确认号用来实现[[可靠传输]]
> 序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上，一个报文段的序号是该报文段首字节的字节流编号![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211129113629.png)
> 确认号：主机A期望从主机B收到的下一个字节的序号
- 校验和字段 [[差错检测]]
- 首部长度：4比特  指示了以32比特的字为单位的TCP首部长度。**典型长度20字节**
- 标志字段：6比特
	- ACK确认字段中的值是有效的
	- RST SYN FIN  用于连接建立和拆除
	- PSH 接收方应立即将数据交给上层
	- URG 报文段里存在着被发送端的上层实体置为“紧急”的数据
	### 

### 往返时间
报文段的样本RTT就是从某报文段被发出到对该报文段的确认被收到之间的时间量，大多数TCP的实现仅在某个时刻做一次SampleRTT测量，为了估计一个典型的RTT，要采取某种对SamleRTT取平均的办法，TCP维持一个SampleRTT均值
TCP根據下列公式更新Esti-matedRTT 
<img src="https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211129142338.png"/>
加权平均对最近的样本赋予的权值要大于对老样本赋予的权值。 越近的样本越能更好地反映网络的当前拥塞情况。从统计学观点讲，这种平均被称为指数加权移动平均测量RTT的变化也是有价值的。 DevRTT定义了RTT偏差 用於估算SampleRtt
1. 一般会偏离EStimatedRTT的程度
	  <img src="https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211129144809.png"/>
2. 设置和管理重传超时间隔超时间隔应该大于等于EstimatedRTT <img src="https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211129144018.png"/>
3. 要求將超时间隔设为EstimatedRTT加上一定余量。SampleRTT值波动较大时，这个余量应该大些；党波动较小时，这个余量应该小些TimeoutInterval的值初始化为1s超时后，TimeoutInt-erval值将加倍收到报文段并更新EstimatedRTT后，TimeoutInterval就得重新计算

### 可靠数据传输
TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏，无间隔，非冗余和按序的数据流
+ 从上层应用程序接收数据
+ 定时器超时，定时器的过期间隔是TimeoutInterval
+ 收到ACK

超时，TCP通过重传起超时的报文段来响应超时事件，然后TCP重启定时器
ACK的值Y与它的变量sendBase进行比较
SendBase是最早未被确认的字节的序号
SendBase-1是指接收方已正确按序收到的数据的最后一个字节的序号
y确认了字节编号在y之前的所有字节都已经收到
y>SendBase，则该ACk是在确认一个或多个先前未被确认的报文段，因为发送方更新他得sendBase变量

TCP是一个累积式的，看起来更像是一个GBN风格的协议

## 流量控制
流量控制用来解决---》接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多，太快，发送得数据就会很容易地使该连接的接受缓存溢出。
流量控制也是一个速度匹配服务
发送方速率与接收方应用程序的读取速率相匹配
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制
  + 接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间
  + 双工通信，在连接两端的发送方都各自维护一个接收窗口
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211130102656.png)
RcvBuffer表示其大小 
LastByteRead:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
LastByteRcvd:从网络中达到的并且已放入主机B接收缓存中的数据流的最后一个字节的编号
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211130103613.png)
## 拥塞控制
TCP发送方也可能因为IP网络的拥塞而被遏制
网络变得拥塞由于路由器缓存溢出引起的丢包，分组重传因此作为网络拥塞的征兆
1. 情况1：两个发送方和一台具有无穷大缓存的路由器。 吞吐量角度看，运行在总吞吐量接近R的状态也许是一个理想状态，但是从时延角度却不是一个理想状态. 分组的到达速率接近链路容量时，分组经历巨大的排队时延。
2. 情况2: 两个发送方和一台具有有限缓存的路由器。 发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。还有另外一种代价，即发送方在遇到大时延所进行的不必要重传会引起路由器理由其链路带宽来转发不必要的分组副本
3. 情况3: 4个发送和具有有限缓存的多台路由器及多跳路径。当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了

### 拥塞控制方法
+ 端到端拥塞控制，在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。TCP报文段的丢失被认为是网络拥塞的迹象，TCP会相应的减少其窗口长度。
+ 网络辅助的拥塞控制，网络层构件向发送方提供关于网络中拥塞状态的显示反馈信息
	+ 直接反馈信息（由网络路由器发送方，阻塞分组）
	+ 路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211224145225.png)

### TCP拥塞控制
1. 端到端拥塞控制
2. TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率
	1. 一个TCP发送方如何限制它向其连接发送流量的速率呢
		1. 运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，拥塞窗口（cwnd），对一个TCP发送方能向网络中发送流量的速率进行了限制![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211224154154.png)
	2. 一个TCP发送如何感知从它到目的地之间的路径存在拥塞呢？要么出现超时，要么收到来自接收方的3个冗余ACK
	3. 发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？TCP将一些确认的到达作为一切正常的指示，即在网络上传输的报文段正被成功地交付给目的地，并使用确认来增加窗口的长度。如果确认以相当慢的速率到达，则该拥塞窗口将以相当慢的速率增加，如果以高速率到达，则拥塞窗口迅速增大，通过**自计时**的
	4. TCP发送方怎样确定它应当发送的速率呢？
		1. 一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率
		2. 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。
		3. 带宽探测
3. TCP拥塞控制算法细节
	1. 慢启动![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211227102058.png)
	cwnd（拥塞窗口）的值以1个MSS开始并且每当传输的报文段首次被确认就增加1个MSS，指数增长（通常初始置为一个MSS的较小值，MSS/RTT，但是可用带宽可能比MSS/RTT大很多）
	何时结束指数增长呢？
	+  cwnd设置为1并重新开始慢启动，将第二个状态变量ssthresh（慢启动阙值的速记）设置为cwnd/2，当检测到拥塞时将ssthreash置为拥塞窗口值得一半。
	+ 当检测到拥塞时ssthreah设为cwnd的值一半，当到达或超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式
	+ 检测到3个冗余ACk，这时TCP执行快速重传并进入快速回复状态
	2. 拥塞避免
	每个RTT只将cwnd的值增加一个MSS、通用的方法是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节
	何时应当结束拥塞避免的线性增长呢？当丢包事件出现时，ssthresh的值被更新为cwnd值得一半。然后再继续送包，当收到3个冗余的ACk，将ssthresh的值记录为cwnd的值得一半，接下来进入快速恢复状态
	3. 快速恢复
	![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211227112645.png)

慢启动与拥塞避免是TCP的强制部分，差异在于对收到的ACK做出反应时增加cwnd的长度方式，慢启动比拥塞避免更快的增加cwnd的长度

### TCP连接管理
#### TCP连接
第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。SYN被设置为1,随机选择一个初始序号（client_isn)，并将此编号放置于该起始的**TCP SYN报文段**的序号字段中。
第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。SYN 被置为1   ， 确认字段为client_isn+1 ，服务器自己的初始序号server_isn
第三步：确认字段server_isn+1，SYN被置为0。 SYN1为请求连接 ， 0 为连接已经建立

#### TCP断开
参与一条TCP连接的两个进程中任何一个都能终止该连接。
当连接结束后，主机中的“资源”将被释放
![](https://minyeon.oss-cn-beijing.aliyuncs.com/tenglingImg/20211227134432.png)
客户应用进程发出一个关闭连接命令，这会引起客户TCP向服务器进程发送一个特殊的TCP报文段，FIN=1 。当服务器接收到该报文段后，就向发送方回送一个确认报文段。服务器请求关闭也是一样的。


## 无连接运输：UDP
最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据
UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口字段，以及两个其他的小字段，然后将形成的报文段交给网络层。
如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程

+ 无需连接建立
+ 无连接状态
+ 分组首部开销小 TCP20个字节，UDP仅用8个字节